
### BUZZ FUNCTIONS ##

### Fonctions pour les deux ###
# Data Table (maintenant adaptable selon le type du bot (chien/mouton))
# y		Data
# 0		Neighbor Azimut
# 1		Neighbor Distance
# 2 	Visibility bit (1 if the bot is visible at this time step)
# 3		Type bit (1 if the bot is the same type)


# Write a table as if it was a matrix
function write_knowledge(k, row, col, val) {
    var key = string.concat(string.tostring(row),"-",string.tostring(col))
    k[key] = val
}

# Read a table as if it was a matrix (bug à voir)
function read_knowledge(k, row, col) {
    var key = string.concat(string.tostring(row),"-",string.tostring(col))
	#log(key, ", ", k[key])
    #if (k[key] == nil) {
    #   log("Warning: reading 'nil' value from the knowledge table, returning -1")
    #    return -1
    #} else {
    #    return k[key]
    #}
	return k[key]
}

# Write informations about the neighborhood in the table
function check_your_neighborhood() {
    # Reset to 0 the visibility of all neighbors
    foreach(knowledge, function(key, value) {
          column = string.sub(key, string.length(key)-1,string.length(key))
          if (column=='2') {
              knowledge[key] = 0
          }
    })
    neighbors.nonkin().foreach( function(rid, data) {
        # For each nonkin neighbor:
        # Record the neighbor azimuth in my own knowledge table
        write_knowledge(knowledge, rid, 0, data.azimuth)
        # Record the neighbor distance in my own knowledge table
        write_knowledge(knowledge, rid, 1, data.distance)
        # Set neighbor as visible
        write_knowledge(knowledge, rid, 2, 1)
		# Set neighbor as different type
        write_knowledge(knowledge, rid, 3, 0)
    })
		neighbors.kin().foreach( function(rid, data) {
        # For each kin neighbor:
        # Record the neighbor azimuth in my own knowledge table
        write_knowledge(knowledge, rid, 0, data.azimuth)
        # Record the neighbor distance in my own knowledge table
        write_knowledge(knowledge, rid, 1, data.distance)
        # Set neighbor as visible
        write_knowledge(knowledge, rid, 2, 1)
		# Set neighbor as same type
        write_knowledge(knowledge, rid, 3, 1)
    })
}

function vec2_str(v) {
	return string.concat("v: x=", string.tostring(v.x), " y=", string.tostring(v.y))
}

function table_print(t) {
  foreach(t, function(key, value) {
    log(key, " -> ", value)
  })
}

function table_v_print(t) {
  foreach(t, function(key, value) {
      log(key, " -> ", vec2_str(value))
    })
}

# Rads to degrees
function rtod(r) {
   return (r*(180.0/math.pi))
}

# Degrees to rads
function dtor(d) {
   return (math.pi*(d/180.0))
}

# printing the contents of a table: a custom function
function table_print(t) {
  foreach(t, function(key, value) {
      log(id,": ",key, " -> ", value)
    })
}

# setting a 2D vector from length and angle
function vec2_new_polar(length, angle) {
   var vec2 = {}
   vec2.x = length * math.cos(angle)
   vec2.y = length * math.sin(angle)
   return vec2
}

# Summing two 2D vectors (v1 = v1 + v2)
function vec2_sum(v1, v2) {
	 v1.x = v1.x + v2.x
   v1.y = v1.y + v2.y
}

function vec2_diff(v1, v2) {
	 v1.x = v1.x - v2.x
   v1.y = v1.y - v2.y
}

function vec2_sum_r(v1, v2) {
	return {.x = v1.x + v2.x, .y =  v1.y + v2.y}
}

function vec2_diff_r(v1, v2) {
	 return {.x = v1.x - v2.x, .y =  v1.y - v2.y}
}

# Getting the angle of a 2D vector
function vec2_angle(v) {
   return math.atan(v.y, v.x)
}

function vec2_length(v) {
	return math.sqrt((v.x * v.x) + (v.y * v.y))
}

# Calculate the opposite direction (verifier pour angle = 0)
function oppdir(azimuth) {
	if (azimuth > 0) {
		return (azimuth - math.pi)
	}
	else {
		return (azimuth + math.pi)
	}
}

# marche aléatoire pour les robots
function random_move() {
	var maxDist = 0
	var maxAngle = 0
	var counter = 0
	while (counter < 8) {
		if ((proximity[counter].angle < 100*math.pi/180) and (proximity[counter].angle > -100*math.pi/180) and (proximity[counter].value > maxDist)) {
			maxDist = proximity[counter].value
			maxAngle = proximity[counter].angle
		}
		counter = counter + 1
	}
	if (maxDist > 0) {
		if (maxAngle > 0) {
			set_wheels(10.0,0.0)
		}
		else {
			set_wheels(0.0,10.0)
		}
	}
	else {
		set_wheels(10.0,10.0)
	}
}

function maximun(distance) {
	var len =  size(distance)
	max = 0
	i = 0
	while (i < len) {
		if (distance [i] > max) {
			max = distance[i]
		}
	i = i + 1
	}
	return max
}

function minimum(distance) {
	min = inf
	foreach(distance, function(key, value) {
		if (value < min ) {
			min = value
		}
	})
	return min
}

function mean(points) {
	mean = {.x = 0, .y = 0}
	points.foreach(function(rid, data) {
		vec2_sum(mean, data)
	})
	return mean / size(points)
}

function kmean(nb_cluster){

	log("nb_cluster: ", nb_cluster)
	points = {}
	robots = {}

	rbt_counter = 0
	neighbors.foreach(function(rid,data) {

	log("robot ", rid, ": ",
        "distance  = ", data.distance, ", ",
        "azimuth   = ", data.azimuth, ", ",
        "elevation = ", data.elevation)

		# if it's visible
		if (read_knowledge(knowledge, rid, 2) == 1) {
			log("it's a visible")
			# if it's a sheep
			if (read_knowledge(knowledge, rid, 3) == 0) {

				log("it's a sheep")
				robots[rbt_counter] = rid
				log("le ", rbt_counter, " robot d'id: ", rid)
				rbt_counter = rbt_counter + 1
				var rb_vct = vec2_new_polar(read_knowledge(knowledge, rid, 1), read_knowledge(knowledge, rid, 0))
				points[rid] = rb_vct
			}
		}
	})

	log("points: ")
	table_v_print(points)

	log("robot id")
	table_print(robots)

	i = 0
	center = {}
	cluster= {}

	while (i < nb_cluster) {
		cluster[i] = {}
		center[i] = points[robots[i]]
		i = i + 1
	}

	log("centers: ")
	table_v_print(center)

	log("debut boucle while")

	post_center = {}
	difference_center = 1000.0

	counter_dist = 0
	distance_tot = 0

	while (counter_dist < 5) {
		distance_tot = 0
		foreach(points, function(id,pt) {

      log("test du pt: ", id, " x:", pt.x, " y:", pt.y)
      var distance = {}
      i = 0
      while (i < nb_cluster) {
        distance[i] = vec2_length(vec2_diff_r(center[i], pt))
        log("distance du ", i, " cluster au pt: ", distance[i])
        i = i + 1
      }
			log("distance: ")
			table_print(distance)

			min_distance = minimum(distance)
			log("min distance: ")
      log(min_distance)

			i = 0
      while ( i < nb_cluster) {
        if(distance[i] == min_distance) {
          log("ajout du point ", id, " au cluster ",i)
					distance_tot = 	distance_tot + min_distance
          cluster[i][id] = pt
					log("cluster ", i, " : ")
					table_v_print(cluster[i])
        }
        i = i + 1
      }
    })
	counter_dist = counter_dist + 1

	}
	return {.distance = distance_tot, .clusters = cluster}
}

### Fonctions pour les chiens ###
# Mouvement des chiens (marche aleatoire pour le moment)
function d_move() {
	if (neighbors.count() != 0) {
		nb_cluster = 2
  	distance = inf
		results = {}
		while (nb_cluster <= 4 and distance > 500) {
			results= kmean(nb_cluster)
			results_3 = kmean(3)
			log("distance", results.distance)
			i = 0
			while ( i < nb_cluster) {
				log("cluster ", i)
				table_v_print(results.clusters[i])
				i = i + 1
			}
			nb_cluster = nb_cluster + 1
			distance = results.distance
		}

		# TODO comportement a partir des clusters
		log("computation des centres de masses")
		clusters = results.clusters
		i = 0
		while ( i < size(clusters)) {
			sum = {.x=0, .y=0}
			foreach(clusters[i], function(id, vector) {
				vec2_sum(sum, vector)
			})
			clusters[i]["mass_center"] = {.x = sum.x / size(clusters[i]), .y = sum.y / size(clusters[i]) }
			log("cluster ", i)
			table_v_print(results.clusters[i])
			i = i + 1
		}
	} else {
	random_move()
	}
}


### Fonctions pour les moutons ###
# Juste un test de reconnaissance de voisins
function beh() {
	var dogs = 0
	dogs =  neighbors.nonkin().count()
	if (dogs != 0) {
		log("BEEEEEEH il y a ", dogs," loooooup!")
	}
}

# Fonction de mouvement du mouton (comportement)
function s_move(threshold) {
	# calcul de l'angle de direction à prendre
	# log("______________________", id)

	# if it's too close, we execute the avoidance algorihtme
	var counter = 0
  var obstacle_vector = vec2_new_polar(0,0)
	# for each captor, we check if there is detection
	while (counter < 8) {
			var frontValue = proximity[counter].value
			var frontAngle = proximity[counter].angle
			if (frontValue != 0) {
					# We sum all the vector define by the value and angle of detection.
					# it will become a good indicator of where is the closest part of the obstacle
					# because we ponderate the angle of detection by his distance to the agent
					vec2_sum(obstacle_vector, vec2_new_polar(frontValue,frontAngle))
			}
			counter = counter + 1
	}
	if ((obstacle_vector.x != 0) or (obstacle_vector.y != 0)) {
			gotop(10.0, vec2_angle(obstacle_vector) + math.pi)
	# if there is no obstacle, we move further close from the center of the herd or away of the dog
	} else {

		var mass_center = vec2_new_polar(0,0)
		var dog_vector = vec2_new_polar(0,0)

		neighbors.foreach(function(rid,data) {
		# if it's visible
			if (read_knowledge(knowledge, rid, 2) == 1) {
			# define the local vector to the robot targeted
				var rb_vct = vec2_new_polar(read_knowledge(knowledge, rid, 1), read_knowledge(knowledge, rid, 0))
			# if it's a sheep
				if (read_knowledge(knowledge, rid, 3) == 1) {
				# if it close enoutgh to be consider inside the same herd
					if (read_knowledge(knowledge, rid, 1) <= threshold) {
					# we determine the average vector to the sheeps, it's the center of the herd
						vec2_sum(mass_center, rb_vct)
					}
				}
			}
		 # if it's the dog, we determine his local vector
			if ((read_knowledge(knowledge, rid, 3) == 0) and (read_knowledge(knowledge, rid, 1) <= threshold)) {
				local_dog_vect = vec2_new_polar(read_knowledge(knowledge, rid, 1), read_knowledge(knowledge, rid, 0))
				vec2_sum(dog_vector, local_dog_vect)
			}
		})

		var direction = {}; direction.x = 0.0; direction.y = 0.0
		# if there is neighbors
  	if (neighbors.count() != 0) {
			# we determine the average  vector from the center of the herd and the wolf to get a natural behavior from the sheep,
			# he wants to get away from the dog, but stay with his herd.
			# log("test: dog_vect x:", dog_vector.x, " y: ", dog_vector.y)
			# log("test: mass_center x:", mass_center.x, " y: ", mass_center.y)

			# if we see the dog, we get away from it, by adding the opposite vector to the direction vector
			if (vec2_length(dog_vector) != 0) {
				# the more the dog is near, the more the sheep will get away by using the inverse of the length of the dog vector
				var escape_dog = vec2_new_polar( 5 * vec2_length(mass_center) ^ 2 / vec2_length(dog_vector), 							vec2_angle(dog_vector) + math.pi)
				# log("escape_dog x:", escape_dog.x, " y: ", escape_dog.y, " len: ", vec2_length(escape_dog))
				vec2_sum(direction, escape_dog)
			}
			vec2_sum(direction, mass_center)
			gotop(10.0, vec2_angle(direction))

		} else {
			random_move()
		}
		# log("___direction: x:", direction.x," y:", direction.y)
	}
}



### Fonctionnement Global ###
# Executed at init time
function init() {
	# Local knowledge table
  knowledge = {}
	# On initialise 2 swarm (dog et sheep) pour différencier deux comportements
	dog = swarm.create(0)
	sheep = swarm.create(1)
	dog.select(id == 0 or id == 1100)
	sheep.select(id != 0 and id != 1100)
}

# Executed every time step
function step() {
	threshold = 150
	sheep.exec(function() { check_your_neighborhood() })
	dog.exec(function() { check_your_neighborhood() })

	dog.exec(function() { d_move() })
	sheep.exec(function() { s_move(150) })
}

# Executed once when the robot (or the simulator) is reset.
function reset() {
}

# Execute at exit
function destroy() {
}
