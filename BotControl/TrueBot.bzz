
### BUZZ FUNCTIONS ##

### Fonctions pour les deux ###
# Data Table (maintenant adaptable selon le type du bot (chien/mouton))
# y		Data
# 0		Neighbor Azimut
# 1		Neighbor Distance
# 2 	Visibility bit (1 if the bot is visible at this time step)
# 3		Type bit (1 if the bot is the same type)


# Write a table as if it was a matrix
function write_knowledge(k, row, col, val) {
    var key = string.concat(string.tostring(row),"-",string.tostring(col))
    k[key] = val
}

# Read a table as if it was a matrix (bug à voir)
function read_knowledge(k, row, col) {
    var key = string.concat(string.tostring(row),"-",string.tostring(col))
	#log(key, ", ", k[key])
    #if (k[key] == nil) {
    #   log("Warning: reading 'nil' value from the knowledge table, returning -1")
    #    return -1
    #} else {
    #    return k[key]
    #}
	return k[key]
}

# Write informations about the neighborhood in the table
function check_your_neighborhood() {    
    # Reset to 0 the visibility of all neighbors
    foreach(knowledge, function(key, value) {
          column = string.sub(key, string.length(key)-1,string.length(key))
          if (column=='2') { 
              knowledge[key] = 0 
          }     
    })    
    neighbors.nonkin().foreach( function(rid, data) {               
        # For each nonkin neighbor:       
        # Record the neighbor azimuth in my own knowledge table
        write_knowledge(knowledge, rid, 0, data.azimuth)        
        # Record the neighbor distance in my own knowledge table
        write_knowledge(knowledge, rid, 1, data.distance)   
        # Set neighbor as visible
        write_knowledge(knowledge, rid, 2, 1)  
		# Set neighbor as different type
        write_knowledge(knowledge, rid, 3, 0)     
    })  
	neighbors.kin().foreach( function(rid, data) {               
        # For each kin neighbor:       
        # Record the neighbor azimuth in my own knowledge table
        write_knowledge(knowledge, rid, 0, data.azimuth)        
        # Record the neighbor distance in my own knowledge table
        write_knowledge(knowledge, rid, 1, data.distance)   
        # Set neighbor as visible
        write_knowledge(knowledge, rid, 2, 1)  
		# Set neighbor as same type
        write_knowledge(knowledge, rid, 3, 1)     
    })  
}

# Rads to degrees
function rtod(r) {
   return (r*(180.0/math.pi))
}

# Degrees to rads
function dtor(d) {
   return (math.pi*(d/180.0))
}

# printing the contents of a table: a custom function
function table_print(t) {
  foreach(t, function(key, value) {
      log(id,": ",key, " -> ", value)
    })
}

# Calculate the opposite direction (verifier pour angle = 0)
function oppdir(azimuth) {
	if (azimuth > 0) {
		return (azimuth - math.pi)
	}
	else {
		return (azimuth + math.pi)
	}
}
	




### Fonctions pour les chiens ###
# Mouvement des chiens (marche aleatoire pour le moment)
function d_move() {
	var maxDist = 0
	var maxAngle = 0
	var counter = 0
	while (counter < 8) {
		if ((proximity[counter].angle < 100*math.pi/180) and (proximity[counter].angle > -100*math.pi/180) and (proximity[counter].value > maxDist)) {
			maxDist = proximity[counter].value
			maxAngle = proximity[counter].angle
		}
		counter = counter + 1
	}
	if (maxDist > 0) {
		if (maxAngle > 0) {
			set_wheels(10.0,0.0)
		}
		else {
			set_wheels(0.0,10.0)
		}
	}
	else {
		set_wheels(10.0,10.0)
	}
}

### Fonctions pour les moutons ###
# Juste un test de reconnaissance de voisins
function beh() {
	var dogs = 0
	dogs =  neighbors.nonkin().count()
	if (dogs != 0) {
		log("BEEEEEEH il y a ", dogs," loooooup!")
	}
}

# Fonction de mouvement du mouton (comportement)
function s_move() {
	# calcul de l'angle de direction à prendre (attention il y a un probleme sur l'angle allande de -pi à pi)
	direction = 0
	neighbors.foreach(function(rid,data) {
		if (read_knowledge(knowledge, rid, 2) == 1) {
			if ((read_knowledge(knowledge, rid, 3) == 1) and (read_knowledge(knowledge, rid, 1) > 50)) {
				direction = direction + read_knowledge(knowledge, rid, 0)	
			}
			if ((read_knowledge(knowledge, rid, 3) == 1) and (read_knowledge(knowledge, rid, 1) < 50)) {
				direction = direction + oppdir(read_knowledge(knowledge, rid, 0))	
			}
			if (read_knowledge(knowledge, rid, 3) == 0) {
				direction = direction + oppdir(read_knowledge(knowledge, rid, 0))
			}
		}
	})


	#Ancienne version sans la table
	#neighbors_dog =  neighbors.nonkin()
	#neighbors_sheep =  neighbors.kin()
	#neighbors_sheep.foreach(function(rid, data) {
	#	direction = direction + data.azimuth
	#})
	#log(id, ": ", direction)
	#neighbors_dog.foreach(function(rid, data) {
	#	direction = direction + oppdir(data.azimuth)
	#})
	
   	if (neighbors.count() != 0) {
		direction = direction / neighbors.count()
		log(direction)
		gotop(10.0,direction)
	}
	else {
		set_wheels(0.0,0.0)
	}
}



### Fonctionnement Global ###
# Executed at init time
function init() {
	# Local knowledge table
  	knowledge = {}
	# On initialise 2 swarm (dog et sheep) pour différencier deux comportements
	dog = swarm.create(0)
	sheep = swarm.create(1)
	dog.select(id == 0 or id == 1100)
	sheep.select(id != 0 and id != 1100)
}

# Executed every time step
function step() {
	dog.exec(function() { check_your_neighborhood() })
	sheep.exec(function() { check_your_neighborhood() })
	#table_print(knowledge)
	dog.exec(function() { d_move() }) 
	sheep.exec(function() { s_move() })	
}

# Executed once when the robot (or the simulator) is reset.
function reset() {
}

# Execute at exit
function destroy() {
}