
### BUZZ FUNCTIONS ##

######################### function of log #########################

#vector to string
function vec2_str(v) {
	return string.concat("v: x=", string.tostring(v.x), " y=", string.tostring(v.y))
}

# print a table
function table_print(t) {
  foreach(t, function(key, value) {
    log(key, " -> ", value)
  })
}

# print a table of vector
function table_v_print(t) {
  foreach(t, function(key, value) {
      log(key, " -> ", vec2_str(value))
    })
}

# Rads to degrees
function rtod(r) {
   return (r*(180.0/math.pi))
}

# Degrees to rads
function dtor(d) {
   return (math.pi*(d/180.0))
}

######################### function for vectors #########################

# setting a 2D vector from length and angle
function vec2_new_polar(length, angle) {
   return {.x = length * math.cos(angle), .y = length * math.sin(angle)}   
}

# Summing two 2D vectors (v1 = v1 + v2)
function vec2_sum(v1, v2) {
	 v1.x = v1.x + v2.x
   v1.y = v1.y + v2.y
}

# Difference for two 2D vector (v1 = v1 - v2)
function vec2_diff(v1, v2) {
	 v1.x = v1.x - v2.x
   v1.y = v1.y - v2.y
}

# Difference for two 2D vector with return
function vec2_sum_r(v1, v2) {
	return {.x = v1.x + v2.x, .y =  v1.y + v2.y}
}

# Summing two 2D vectors with return
function vec2_diff_r(v1, v2) {
	 return {.x = v1.x - v2.x, .y =  v1.y - v2.y}
}

# Getting the angle of a 2D vector
function vec2_angle(v) {
   return math.atan(v.y, v.x)
}

# Getting the length of a 2D vector
function vec2_length(v) {
	return math.sqrt((v.x * v.x) + (v.y * v.y))
}

# Rotation 2D by an angle 
function vec2_rot(v1, angle) {
	return {.x = v1.x * math.cos(angle) - v1.y * math.sin(angle), .y =  v1.x * math.sin(angle) + v1.y * math.cos(angle)}
}

# multiplication by a constant
function vec2_scale(v1, const) {
	return {.x = v1.x * const, .y =  v1.y * const}
}



######################### function for tables #########################

# Find the maximal value of a table
function maximun(distance) {
	max = 0
	foreach(distance, function(key, value) {
		if (value > max ) {
			max = value
		}
	})
	return max
}

# Find the minimal value of a table
function minimum(distance) {
	min = inf
	foreach(distance, function(key, value) {
		if (value < min ) {
			min = value
		}
	})
	return min
}

######################### function tables of vectors #########################

# find the mean value of a table of vector
function mean(points) {
	mean_vec = {.x = 0, .y = 0}
	foreach(points, function(rid, data) {
		vec2_sum(mean_vec, data)
	})
	return {.x = mean_vec.x / size(points), .y = mean_vec.y / size(points)}
}

######################### function for robots #########################
# Compte des voisins sans prendre en compte RID 0
function custom_count() {
	compteur = 0
	neighbors.foreach(function(rid, data) {
		if (rid != 0) {
			compteur = compteur +1
		}
	})
	return compteur
}


# marche aléatoire pour les robots
function random_move() {
	var maxDist = 0
	var maxAngle = 0
	var counter = 0
	while (counter < 8) {
		if ((proximity[counter].angle < 100*math.pi/180) and (proximity[counter].angle > -100*math.pi/180) and (proximity[counter].value > maxDist)) {
			maxDist = proximity[counter].value
			maxAngle = proximity[counter].angle
		}
		counter = counter + 1
	}
	if (maxDist > 0) {
		if (maxAngle > 0) {
			set_wheels(10.0,0.0)
		}
		else {
			set_wheels(0.0,10.0)
		}
	}
	else {
		set_wheels(10.0,10.0)
	}
}

# Single-linkage Algorithm
# return the clusters and the total distance of all point from the center of the cluster
function singleLinkage(threshold, verbose) {
	# inspired from the scipy function (cf the github)

	points = {}
	robots = {}
	clusters = {}
	rbt_counter = 0

	neighbors.nonkin().foreach(function(rid, data) {
		if (rid != 0) {
			robots[rbt_counter] = rid 
			points[rid] = vec2_new_polar(data.distance, data.azimuth)	
			rbt_counter = rbt_counter + 1
		}	
	})

	i = 0
	var mat_dist = {}
	while (i < rbt_counter) {
		mat_dist[i] = {}
		j = 0
		while (j < rbt_counter) {
			mat_dist[i][j] = vec2_length(vec2_diff_r(points[robots[i]], points[robots[j]]))
			j = j + 1
		}
		i = i + 1
	}

	# i = 0
	# while (i < rbt_counter) {
	# 	log(robots[i], " : ")
	# 	table_print(mat_dist[i])
	# 	i = i + 1
	# }

	# reduced matrix (a one line distance matrix)
	mat_dist_reduite = pdist(mat_dist, rbt_counter)
	# single linkage algorithm 
	mat_Z = mst_single_linkage(mat_dist_reduite, rbt_counter)
	# cluster matrix (link between an individual and his cluster)
	mat_cluster = cluster_matrix(mat_Z, rbt_counter, 150)
 	# Cluster representation as we need for the d_move algorithm
	clust = cluster_creator(mat_cluster, rbt_counter, robots, points)
	

	if(verbose) {
		log("Reduced matrix")
		table_print(mat_dist_reduite)
		log(" ")
		log("Computed linkage matrix")
		i = 0
		while (i < rbt_counter-1) {
			table_print(mat_Z[i])
			i = i + 1
		}
		log(" ")
		log("Clusters matrix")
		table_print(mat_cluster)
		log(" ")
		log("Clusters")
		i = 0
		while (i < clust.nbre_cluster) {
			log("Cluster ", i, ": ")
			table_v_print(clust.clusters[i])
			i = i + 1
		}
	}
	return {.clusters = clust.clusters, .nbre_cluster = clust.nbre_cluster}
}

function pdist(D, n) {
	# IN:
	# D is the complete distance matrix 
	# n is the number of individuals in the matrix

	# OUT:
	# y is the reduced matrix

	# EXEMPLE (visuel)
	# D = [0    281  251
	#	   281  0    101
	#	   251  101  0  ]
	# y = pdist(D,3)
	# y = [281  251  101]

	ind1 = 0	# first individual
	indc = 0	# current treated distance
	var y = {}
	while (ind1 < n-1) {
		ind2 = ind1 + 1 	# second individual
		while (ind2 < n) {
			y[indc] = D[ind1][ind2]
			indc = indc + 1
			ind2 = ind2 + 1
		}
		ind1 = ind1 + 1
	}
	return y
}

function condensed_index (n, i, j) {
	# IN:
	# n is the number of individuals in the matrix
	# i is the index of the first individual
	# j is the index of the second individual

	# OUT:
	# corresponding index in the reduced matrix

	if (i < j) {
		return n*i - (i*(i+1)/2) + (j-i-1)
	}
	else if (i > j) {
		return n*j - (j*(j+1)/2) + (i-j-1)
	}
}

function mst_single_linkage(dists, n) {
	# IN:
	# dists is the condensed distance matrix 
	# n is the number of individuals in the complete matrix

	# OUT:
	# Z is the computed linkage matrix
	# 	Z[i][0] is the first individual in the couple
	# 	Z[i][1] is the second individual in the couple
	# 	Z[i][2] is the distance of the two individuals

	# EXEMPLE (visuel)
	# y = [281  251  101]
	# Z = mst_single_linkage(y,3)
	# Z = [[2  1  101]
	#	   [0  2  251]
	#	   [1  0  281]]

	# to take account of the already merged individuals
	var Z = {}
		
	var merged = {}
	var D = {}
	b = 0
	while (b < n) {
		merged[b] = 0
		D[b] = math.inf
		Z[b] = {}
		b = b + 1
	}

	var i 
	var k 
	var x 
	var y
	var dist
	var current_min

	x = 0
	k = 0
	while (k < n-1) {
		current_min = math.inf
		merged[x] = 1
		i = 0
		while (i < n) {
			if (merged[i] != 1) {
				
				dist = dists[condensed_index(n, x, i)]
				if (D[i] > dist) {
					D[i] = dist
				}
				if (D[i] < current_min) {
					y = i
					current_min = D[i]
				}
			}
			i = i + 1
		}

		Z[k] = {.0 = x, .1 = y, .2 = current_min}
		x = y
		k = k + 1
	}
	return Z
}


function cluster_matrix(Z, n, thresh) {
	# IN:
	# Z is the computed linkage matrix
	# 	Z[i][0] is the first individual in the couple
	# 	Z[i][1] is the second individual in the couple
	# 	Z[i][2] is the distance of the two individuals
	# n is the number of individuals
	# tresh is the treshold distance to consider 2 individuals in the same cluster

	# OUT:
	# clust is the cluster matrix 
	# clust is a n-size matrix with the cluster associated for each individuals

	# EXEMPLE (visuel)
	# Z = [[2  1  101]
	#	   [0  2  251]
	#	   [1  0  281]]
	# clust = cluster_matrix(Z, 3, 150)
	# clust = [0  1  1]

	var indc = 0 #couple index
	var x
	var y
	var i
	var compare
	var clust_min
	var current_min
	var current_max
	var diff
	var clust = {}

	# initially, each individual is in his own cluster
	var b = 0
	while (b < n) {
		clust[b] = b
		b = b + 1
	}

	# first clustering: clusters index are not from 0 to clust_max
	while (indc < n-1) {
		if (Z[indc][2] < thresh) {
			x = math.min(Z[indc][0], Z[indc][1])
			y = math.max(Z[indc][0], Z[indc][1])
			i = 0
			compare = clust[y]
			while (i < n) {
				if (clust[i] == compare) {
					clust[i] = clust[x]
				}
				i = i + 1
			}
		}
		indc = indc + 1
	}

	# second clustering with good clusters index
	clust_min = 0
	while (clust_min < current_max) {
		current_min = 100000000
		current_max = 0
		indc = 0
		while (indc < n) {
			if (clust[indc] >= clust_min) {
				if (clust[indc] < current_min) {
					current_min = clust[indc]
				}
				if (clust[indc] > current_max) {
					current_max = clust[indc]
				}
			}
			indc = indc + 1
		}
		diff = current_min - clust_min
		if (diff > 0) {
			indc = 0
			while (indc < n) {
				if (clust[indc] > clust_min) {
					clust[indc] = clust[indc] - diff
				}
				indc = indc + 1
			}
		}
	clust_min = clust_min + 1
	}
	return clust
}

function cluster_creator(C, n, R, P) {
	# IN:
	# C is a n-size matrix with the cluster associated for each individuals
	# n is the number of individuals
	# R is the robot identifiant matrix
	# P is the positions x and y for each robots in R

	# OUT:
	# clusters as we need for d_move
	# nbre_cluster 

	# EXEMPLE (visuel)
	# C = [0  1  1]
	# R = [2  3  4]
	# exemple: P[2].x = 18, P[2].y = -103
	# clusters = cluster_creator(C, 3, R, P)
	# exemple: clusters[0][2] = [18  -103]
	#		 cluster_id ^  ^ robot_id 
	
	var C_copy = C
	var nbre_cluster = 0
	var indr  # robot index
	var indc  # cluster index
	var clusters = {}

	indr = 0
	while (indr < n) {
		if (C_copy[indr] > nbre_cluster) {
			nbre_cluster = C_copy[indr]
		}
		indr = indr + 1
	}
	nbre_cluster = nbre_cluster + 1

	indc = 0
	while (indc < nbre_cluster) {
		clusters[indc] = {}
		indr = 0
		while (indr < n) {
			if (C_copy[indr] == indc) {
				clusters[indc][R[indr]] = {}
				clusters[indc][R[indr]] = P[R[indr]]
			}
			indr = indr + 1
		}
		indc = indc + 1
	}
	# calcul des centres de masse pour chaque cluster
	foreach(clusters, function (i, cluster) {
		clusters[i]["mass_center"] = mean(clusters[i])
	})


	return {.clusters = clusters, .nbre_cluster = nbre_cluster}
}



### Fonctions pour les chiens ###



# Mouvement des chiens (marche aleatoire pour le moment)
function d_test() {
	# log(pose.orientation.yaw," ",pose.orientation.pitch," ",pose.orientation.roll)
	# log(pose.position.x," ",pose.position.y)
	
	
	x1 = pose.position.x
	y1 = pose.position.y
	x2 = objective[obj_i].x
	y2 = objective[obj_i].y
	hyp = math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))
	angle = math.acos(math.abs(x2-x1)/hyp)
	
	if(x1<x2) {
		if(y1<y2) {
			angle2 =  (angle - pose.orientation.yaw)
		} else {
			angle2 =  (- angle - pose.orientation.yaw)
		}
	} else {
		if(y1<y2) {
			angle2 =   - (math.pi - (-angle - pose.orientation.yaw))
		} else {
			angle2 =  - (math.pi - (angle - pose.orientation.yaw))
		}
	}
	
	
	length = hyp*100
	# log("triangle: ",angle*180/math.pi,",robot: ",pose.orientation.yaw*180/math.pi)
	# debug.print(dist,", ",angle2*180/math.pi)
	vec_obj = vec2_new_polar(length, angle2)
	# vec_obj = {.x = objective.x - pose.position.x , .y = objective.y - pose.position.y }
	# debug.print("objectif: ", vec2_str(vec_obj))
	gotoc(vec_obj.x, vec_obj.y)

	if(length<10) {
		obj_i = obj_i + 1
	}
	
}


function dist_angle_gps(p1, o1, p2) {
	#p1: position du point 1 en x,y en coordonnées gps
	#o1: orientation gps du point 1
	#p2: position du point 2 en x,y en coordonnées gps
	x1 = p1.x
	y1 = p1.y
	x2 = p2.x
	y2 = p2.y
	hyp = math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1))
	angle_tri = math.acos(math.abs(x2-x1)/hyp)

	if(x1<x2) {
		if(y1<y2) {
			angle =  (angle_tri - o1)
		} else {
			angle =  (- angle_tri - o1)
		}
	} else {
		if(y1<y2) {
			angle =   - (math.pi - (-angle_tri - o1))
		} else {
			angle =  - (math.pi - (angle_tri - o1))
		}
	}
	length = hyp * 100
	return{.length = length, .angle = angle}
}


function d_move(threshold) {

	# On trouve la direction vers l'objectif grâce à la fonctionnalité GPS du chien
	obj = dist_angle_gps(pose.position, pose.orientation.yaw, objective[obj_i])
	vec_obj = vec2_new_polar(obj.length, obj.angle)
	#debug.print("objectif: ", vec2_str(vec_obj))

	if (neighbors.count() >= 1) {
		# On trouve les différents clusters et leur centre de masse avec un algorithme de single linkage
		results = singleLinkage(threshold, 0)
		clusters = results.clusters
		# On choisi le cluster le plus éloigné pour ne pas "bloquer" sur un cluster
		cluster_cible = clusters[0]
		foreach(clusters, function (i, cluster) {
			if (vec2_length(vec2_diff_r(vec_obj, clusters[i]["mass_center"])) > vec2_length(vec2_diff_r(vec_obj, cluster_cible["mass_center"]))) {
				cluster_cible = clusters[i]
			}
		})


		var cm_var = vec2_rot(cluster_cible.mass_center, pose.orientation.yaw) 
		cm_var = vec2_scale(cm_var, 0.01) 
		cm_gps = vec2_sum_r(pose.position, cm_var)
		
		
		if (vec2_length(vec2_diff_r(vec_obj, cluster_cible.mass_center)) > 30) {

			#log("cluster_cible: ")
			#table_v_print(cluster_cible)
			if (vec2_length(cluster_cible.mass_center) >= threshold * 1.1) {
				#log("on rejoint le cluster")
				gotop(10, vec2_angle(cluster_cible.mass_center))
			} else if (vec2_length( cluster_cible.mass_center) < threshold * 0.5) {
				#log("on est trop pret")
				zero()
			} else {
				#log("on est a portée")
				ortho = {.x = 0, .y = 0}
				orhto1 = {.x = cluster_cible.mass_center.y, .y = -cluster_cible.mass_center.x}
				orhto2 = {.x = -cluster_cible.mass_center.y, .y = cluster_cible.mass_center.x}
				if (vec2_length(vec2_diff_r(vec_obj, orhto1)) > vec2_length(vec2_diff_r(vec_obj, orhto2))) {
					ortho = orhto1
				} else {
					ortho = orhto2
				}
				#log("orthogonal", vec2_str(ortho))
				#log("coef de col: ", vec_obj.x * cluster_cible.mass_center.y - vec_obj.y * cluster_cible.mass_center.x)
				if (math.abs(vec_obj.x * cluster_cible.mass_center.y - vec_obj.y * cluster_cible.mass_center.x) > 1000) {
					#log("pas colinéaire ")
					gotop(10, vec2_angle(ortho))
				} else {
					#log("colinéaire !!")				
					gotop(5, vec2_angle(vec_obj)) #possible pb ici
				} 
			} 
		} else {
			if (obj_i < size(objective)) {
				
				obj_i = obj_i + 1
				log(obj_i,": ",objective[obj_i].x," ",objective[obj_i].y )
				
			} else {
				zero()
			}
		}
	} else {
		random_move()
	}
}

### Fonctions pour les Moutons ###
# Fonction de mouvement du mouton (comportement)
function s_move(threshold) {
	# log("threshold: ", threshold)
	# calcul de l'angle de direction à prendre
	#log("______________________", id)

	# if it's too close, we execute the avoidance algorihtme
  obstacle_vector = {.x=0.0, .y=0.0}
	mass_center = {.x=0.0, .y=0.0}
	dog_vector = {.x=0.0, .y=0.0}

	count_obs = 0
	count_mass_center = 0
	count_dog_vector = 0

	neighbors.kin().foreach(function(rid, data) {
		if ((data.distance <= threshold)) {
			vec2_sum(mass_center, vec2_new_polar(data.distance, data.azimuth))
			count_mass_center = count_mass_center + 1
		}
		if (data.distance <= 30) {
			vec2_sum(obstacle_vector, vec2_new_polar(data.distance, data.azimuth))
			count_obs = count_obs + 1
		}
	})
		
	neighbors.nonkin().foreach(function(rid, data) {
		if ((data.distance <= threshold)) {
			vec2_sum(dog_vector, vec2_new_polar(data.distance, data.azimuth))
			count_dog_vector = count_dog_vector + 1
		}
		if (data.distance <= 30) {
			vec2_sum(obstacle_vector, vec2_new_polar(data.distance, data.azimuth))
			count_obs = count_obs + 1
		}
	})
	
	if (count_obs != 0) {
		obstacle_vector = {.x=obstacle_vector.x / count_obs, .y=obstacle_vector.y / count_obs}
	}
	if (count_mass_center != 0) {
		mass_center = {.x=mass_center.x / count_mass_center, .y=mass_center.y / count_mass_center}
	}
	if (count_dog_vector != 0) {
		dog_vector = {.x=dog_vector.x / count_dog_vector, .y=dog_vector.y / count_dog_vector}
	}
	
	#log(count_obs, " obstalces, ", count_mass_center, " voisins, ", count_dog_vector, " chien")

	escape_dog = {.x = 0.0, .y = 0.0}
	escape_obs = {.x = 0.0, .y = 0.0}

	var direction = {.x=0.0, .y=0.0}
	# if there is neighbors
  if (vec2_length(mass_center) != 0 or vec2_length(dog_vector) != 0) {
		# we determine the average  vector from the center of the herd and the wolf to get a natural behavior from the sheep,
		# he wants to get away from the dog, but stay with his herd.
		
		#log("dog_vect x:", dog_vector.x, " y: ", dog_vector.y, " len: ", vec2_length(dog_vector))
		#log("mass_center x:", mass_center.x, " y: ", mass_center.y, " len: ", vec2_length(mass_center))

		# if we see the dog, we get away from it, by adding the opposite vector to the direction vector
		
		# if the dog is visible
		if (vec2_length(dog_vector) != 0) {
			# and if other sheep are visible
			if (vec2_length(mass_center) != 0) {
				# We compute a excape vector, of the opposite direction of the dog
				# we make sure that the closer the dog is, the bigger the escape vector will be
				escape_dog = vec2_new_polar( vec2_length(mass_center) ^ 2 / vec2_length(dog_vector), 	vec2_angle(dog_vector) + math.pi)
			
			} else {
				# if no sheep is visible, we juste escape the dog
				escape_dog = vec2_new_polar( 1, 	vec2_angle(dog_vector) + math.pi)
			}
			#log("escape_dog x:", escape_dog.x, " y: ", escape_dog.y, " len: ", vec2_length(escape_dog))
			vec2_sum(direction, escape_dog)
		}

		if (vec2_length(obstacle_vector) != 0) {
			# and if dog s visible
			if (vec2_length(escape_dog) != 0) {
				# We compute a excape vector, of the opposite direction of the obstacle
				# we make sure that it will be twice a big as the dog vector
				escape_obs = vec2_new_polar(2 * vec2_length(escape_dog), 	vec2_angle(obstacle_vector) + (math.pi))
			
			} else {
				# if no dog is visible, we juste escape the dog
				escape_obs = vec2_new_polar( 1, 	vec2_angle(obstacle_vector) + (math.pi))
			}
			#log("escape_obs x:", escape_obs.x, " y: ", escape_obs.y, " len: ", vec2_length(escape_obs))
			vec2_sum(direction, escape_obs)
		
		# if there is no obstacle, we go closer to the center of mass
		} else if (vec2_length(mass_center) != 0) {
			vec2_sum(direction, mass_center)
		}
		gotop(10.0, vec2_angle(direction))

	} else {
		zero()
	}
	# debug.rays.add(0,0,0, mass_center.x, mass_center.y, 0.0)
	# debug.rays.add(255,0,0, escape_dog.x, escape_dog.y, 0.0)
	# debug.rays.add(0,255,0, escape_obs.x, escape_obs.y, 0.0)
	# debug.rays.add(0,0,255, direction.x, direction.y, 0.0)

	# log("___direction: x:", direction.x," y:", direction.y)
	
}

### Fonctions pour l'objectif ###
# Ne pas bouger
function zero() {   
	# Do not move
	goto(0.0,0.0)     
}





### Fonctionnement Global ###
# Executed at init time
function init() {
	# Point fixe (x,y)
	objective = {}
	# Test classique
	# objective[1] = {.x = 3, .y = 0}

	# Test Path
	# objective[1] = {.x = -3, .y = 2}
	# objective[2] = {.x = -2, .y = -2}
	# objective[3] = {.x = 0, .y = -3}
	# objective[4] = {.x = 2, .y = -2}
	# objective[5] = {.x = 3, .y = 3}

	# Test Race
	objective[1] = {.x = 5, .y = 0}

	# On initialise 2 swarm (dog et sheep) pour différencier deux comportements
	dog = swarm.create(1)
	sheep = swarm.create(2)
	dog.select(id == 0 or id == 100)
	sheep.select(id != 0 and id != 100)
	
	obj_i = 1
}

# Executed every time step
function step() {

	# debug.print("test au dessus du robot")
	# debug.rays.add("255,255,255, x, y, z)
	# debug.clear()
	debug.rays.clear()
	threshold = 100

	#dog.exec(function() { d_test() })
	dog.exec(function() { d_move(threshold) })
	sheep.exec(function() { s_move(threshold) })
	
	
	
	
}

# Executed once when the robot (or the simulator) is reset.
function reset() {
}

# Execute at exit
function destroy() {
}
